DECLARE PLUGIN "coq-mebi.mebi"

{
(* If we forget this line and include our own tactic definition using
  TACTIC EXTEND, as below, then we get the strange error message
  no implementation available for Tacentries, only when compiling
  theories/Loader.v *)
open Ltac_plugin

(* This one is necessary, to avoid message about missing wit_string *)
open Stdarg
(* open Pp *)
}

(* https://github.com/rocq-prover/rocq/blob/master/doc/plugin_tutorial/tuto0/src/g_tuto0.mlg *)
(* https://github.com/rocq-prover/rocq/blob/master/doc/plugin_tutorial/tuto1/src/g_tuto1.mlg *)
(* https://github.com/rocq-prover/rocq/blob/master/doc/plugin_tutorial/tuto2/src/g_tuto2.mlg *)

(* https://github.com/rocq-prover/rocq/blob/master/dev/doc/parsing.md *)

(* https://github.com/ybertot/plugin_tutorials/blob/master/tuto1/src/g_tuto1.mlg *)

(* TACTIC EXTEND MeBi_unfold
| [ "MeBi_unfold" reference(i) ] -> { Tactics.unfold_body i }
(* | [ "MeBi_unfold" ident(i) ident(j) ] -> { Proofview.tclTHEN (Tactics.unfold_body i)(Tactics.unfold_body j) } *)
(* | [ "MeBi_unfold" ] -> { Tactics.unfold_body (Names.Id.of_string_soft "TheH") } *)
END *)

(* TACTIC EXTEND MeBi_intro
| [ "MeBi_intro" ident(i) ] -> { Tactics.introduction i }
| [ "MeBi_intro" ] -> { Tactics.introduction (Names.Id.of_string_soft "TheH") }
END *)

(* VERNAC COMMAND EXTEND MeBi_Proof CLASSIFIED AS QUERY
| ![ proof ]["MeBi_Proof"] -> 
  { fun ~pstate ->

  }
END *)

VERNAC COMMAND EXTEND MeBi_Debug CLASSIFIED AS QUERY
| [ "MeBi_Debug" "ProofNames" ] ->
  { Mebi_wrapper.run (
      if Logging.is_debug_enabled () then Logging.Log.override "\n";
      Logging.Log.debug "MeBi_Debug:ProofNames: BEGIN";
      let open Mebi_wrapper.Syntax in 
      let* _ = Mebi_wrapper.show_names () in
      Logging.Log.debug "MeBi_Debug:ProofNames: END";
      Mebi_wrapper.return ()
    ) 
  }
| [ "MeBi_Debug" "ThisProof" ] ->
  { Mebi_wrapper.run (
      if Logging.is_debug_enabled () then Logging.Log.override "\n";
      Logging.Log.debug "MeBi_Debug:ThisProof: BEGIN";
      let open Mebi_wrapper.Syntax in 
      let* _ = Mebi_wrapper.show_proof () in
      let* _ = Mebi_wrapper.show_proof_data () in 
      Logging.Log.debug "MeBi_Debug:ThisProof: END";
      Mebi_wrapper.return ()
    ) 
  }
END

(* NOTE: vernac states: 
https://data.code.gouv.fr/hosts/GitHub/repositories/coq%2Fplatform?sha=V8.17.0&path=coqpp%2Fcoqpp_main.ml 

let understand_state = function
  | "close_proof" -> "vtcloseproof", false
  | "open_proof" -> "vtopenproof", true
  | "proof" -> "vtmodifyproof", false
  | "proof_opt_query" -> "vtreadproofopt", false
  | "proof_query" -> "vtreadproof", false
  | "read_program" -> "vtreadprogram", false
  | "program" -> "vtmodifyprogram", false
  | "declare_program" -> "vtdeclareprogram", false
  | "program_interactive" -> "vtopenproofprogram", false
  | s -> fatal ("unsupported state specifier: " ^ s) 
*)

(* NOTE: ![proof] is modify state: https://rocq-prover.org/doc/V8.20.0/api/coq-core/Vernactypes/index.html#val-vtmodifyproof  *)
(* VERNAC COMMAND EXTEND MeBi_cofix CLASSIFIED AS QUERY
| ![ proof ]["MeBi_cofix"] -> 
   { fun ~pstate -> 
      let p = Mebi_wrapper.run ~keep_proof:true (
        let open Mebi_wrapper.Syntax in
        let* _ = Mebi_wrapper.show_names () in 
        let* n = Mebi_wrapper.new_name_of_string "TestCofix" in
        let* _ = Mebi_wrapper.show_names () in 
        let (p, _b) = Declare.Proof.by (Tactics.cofix (n)) pstate in 
        Mebi_wrapper.return p ) in 
      Logging.Log.override "vernac, check names:";
      let _ = Mebi_wrapper.run ~keep_proof:true (
        let open Mebi_wrapper.Syntax in
        let* _ = Mebi_wrapper.show_names () in 
        Mebi_wrapper.return ()) in
      p
   }
END *)
VERNAC COMMAND EXTEND MeBiSim CLASSIFIED AS QUERY
|![ proof ] 
  [ "MeBiSim" "TODO" ] ->
  { fun ~pstate -> 
    Mebi_wrapper.run ~new_proof:false ~proof:(Some pstate) (
      if Logging.is_debug_enabled () then Logging.Log.override "\n";
      Logging.Log.debug "MeBiSim:TODO BEGIN";
      (*  *)
      (* let open Mebi_wrapper.Syntax in  *)
      (*  *)
      Logging.Log.debug "MeBiSim:TODO END";
      Mebi_wrapper.get_proof ()
    )
  }
(*  *)
|![ proof ] 
  [ "MeBiSim" "Proofview_monadTest" ] ->
  { fun ~pstate -> 
    Mebi_wrapper.run ~new_proof:false ~proof:(Some pstate) (
      if Logging.is_debug_enabled () then Logging.Log.override "\n";
      Logging.Log.debug "MeBiSim:Proofview_monadTest BEGIN";
      (*  *)
      (* let open Mebi_wrapper.Syntax in  *)
      (* let* the_proof : Declare.Proof.t = Mebi_wrapper.get_proof () in 
      let the_proof : Proof.t = Declare.Proof.get the_proof in
      let the_data : Proof.data = Proof.data the_proof in
      let* _ = (match the_data.stack with 
      | [] -> 
        Logging.Log.debug "MeBiSim:Proofview_monadTest, stack: empty";
        Mebi_wrapper.return ()
      | h::_ -> (
        Logging.Log.debug (Printf.sprintf "MeBiSim:Proofview_monadTest, stack:\n- h.1: %s\n- h.2" (Utils.pstr_evar_list (fst h)) (Utils.pstr_evar_list (snd h)));
        let _goal_state : Proofview_monad.goal_with_state = 
          Proofview_monad.with_empty_state h 
        in
        let _the_concl : EConstr.types = Tacmatch.pf_concl 
        Mebi_wrapper.return ()
      )) in  *)
      (*  *)
      Logging.Log.debug "MeBiSim:Proofview_monadTest END";
      Mebi_wrapper.get_proof ()
    )
  }
(*  *)
|![ proof ] 
  [ "MeBiSim" "GoalTest" ] ->
  { fun ~pstate -> 
    Mebi_wrapper.run ~new_proof:false ~proof:(Some pstate) (
      if Logging.is_debug_enabled () then Logging.Log.override "\n";
      Logging.Log.debug "MeBiSim:GoalTest BEGIN";
      (* let open Mebi_wrapper.Syntax in  *)
      (* TODO: check out using [tclSELECT] https://rocq-prover.org/doc/V8.20.0/api/coq-core/Goal_select/index.html *)
      Logging.Log.debug (Printf.sprintf "MeBiSim:GoalTest, Default Goal Selector: %s" (Utils.ppstr (Goal_select.pr_goal_selector (Goal_select.get_default_goal_selector ()))));
      let open Mebi_wrapper.Syntax in 
      let* _ = Mebi_wrapper.update_proof_by_tactic (Goal_select.tclSELECT (Goal_select.get_default_goal_selector ()) (Proofview.tclUNIT ())) in
      let* _ = Mebi_wrapper.show_proof_data () in 
      Logging.Log.debug "MeBiSim:GoalTest END";
      Mebi_wrapper.get_proof ()
    )
  }
(*  *)
|![ proof ] 
  [ "MeBiSim" "FocusTest" ] ->
  { fun ~pstate -> 
    Mebi_wrapper.run ~new_proof:false ~proof:(Some pstate) (
      if Logging.is_debug_enabled () then Logging.Log.override "\n";
      Logging.Log.debug "MeBiSim:FocusTest BEGIN";
      (* NOTE: tests *)
      let open Mebi_wrapper.Syntax in 
      let* proof = Mebi_wrapper.get_proof () in
      let the_proof : Proof.t = Declare.Proof.get proof in
      (* let _focus_kind = Proof.new_focus_kind "test_focus_kind" in
      let _focus_cond = Proof.no_cond _focus_kind in
      let _focused_proof : Proof.t =
        Proof.focus _focus_cond "test_focus_kind" 1 the_proof
      in *)
      let the_data = Proof.data the_proof in
     let goals_string = Utils.pstr_evar_list the_data.goals in
     let all_goals_string =
       Utils.pstr_evar_list (Evar.Set.to_list (Proof.all_goals the_proof))
     in
     (* let* sigma = get_sigma in 
     Evar.Set.iter (fun (e:Evar.t) -> 
      Logging.Log.debug (
        Printf.sprintf "MeBiSim:FocusTest, all goals (%s) is_ground_term %b, is_ground_env %b, has_undefined_evars: %b" 
        (Utils.ppstr (Evar.print e)) 
        (Evarutils.is_ground_term sigma ))) 
      (Proof.all_goals the_proof); *)
     let stack_string =
       if List.is_empty the_data.stack
       then "[ ] (empty)"
       else
         Printf.sprintf
           "[%s]"
           (List.fold_left
              (fun (acc : string) ((a, b) : Evar.t list * Evar.t list) ->
                Printf.sprintf
                  "%s\n%s%s,\n%s%s\n"
                  acc
                  (Utils.str_tabs 1)
                  (Utils.pstr_evar_list ~indent:2 a)
                  (Utils.str_tabs 1)
                  (Utils.pstr_evar_list ~indent:2 b))
              ""
              the_data.stack)
     in
     Logging.Log.debug
       (Printf.sprintf
          "MeBiSim:FocusTest, name: %s\n\
           - is done: %b\n\
           - no focused goal: %b\n\
           - goals: %s\n\
           - all goals: %s\n\
           - stack %s\n\
           - pr_proof %s\n"
          (Names.Id.to_string the_data.name)
          (Proof.is_done the_proof)
          (Proof.no_focused_goal the_proof)
          goals_string
          all_goals_string
          stack_string
          (Utils.ppstr (Proof.pr_proof the_proof)));
    
      Logging.Log.debug "MeBiSim:FocusTest END";
      Mebi_wrapper.return proof
    )
  }
(*  *)
|![ proof ] 
  [ "MeBiSim" "WeakNone" ] ->
  { fun ~pstate -> 
    Mebi_wrapper.run ~new_proof:false ~proof:(Some pstate) (
      if Logging.is_debug_enabled () then Logging.Log.override "\n";
      Logging.Log.debug "MeBiSim:WeakNone BEGIN";
      (* NOTE: do as many weak actions as possible  *)
      let open Mebi_wrapper.Syntax in 
      let* _ = Mebi_wrapper.update_proof_by_tactics_mm 
        [ Mebi_tactics.apply_mm Mebi_theories.c_wk_none
        ; Mebi_tactics.unfold_econstr_mm Mebi_theories.c_silent
        ; Mebi_tactics.eapply_mm Mebi_theories.c_rt1n_trans
        ; Mebi_tactics.unfold_econstr_mm Mebi_theories.c_tau
        (* TODO: figure out how to actually get the term in the goal *)
        ] in 
      let* _ = Mebi_wrapper.show_proof_data () in 
      Logging.Log.debug "MeBiSim:WeakNone END";
      Mebi_wrapper.get_proof ()
    )
  }
|![ proof ] 
  [ "MeBiSim" "WeakSome" ] ->
  { fun ~pstate -> 
    Mebi_wrapper.run ~new_proof:false ~proof:(Some pstate) (
      if Logging.is_debug_enabled () then Logging.Log.override "\n";
      Logging.Log.debug "MeBiSim:WeakSome BEGIN";
      (* TODO: do strong action *)
      let open Mebi_wrapper.Syntax in 
      let* _ = Mebi_wrapper.update_proof_by_tactics_mm 
        [ Mebi_tactics.apply_mm Mebi_theories.c_wk_some
        ] in 
      (*  *)
      Logging.Log.debug "MeBiSim:WeakSome END";
      Mebi_wrapper.get_proof ()
    )
  }
(*  *)
|![ proof ] 
  [ "MeBiSim" "Inv" ] ->
  (* TODO: maybe this stuff could be in coq anyway, and used by [mebi_theories] *)
  { fun ~pstate -> 
    Mebi_wrapper.run ~new_proof:false ~proof:(Some pstate) (
      if Logging.is_debug_enabled () then Logging.Log.override "\n";
      Logging.Log.debug "MeBiSim:TODO BEGIN";
      (*  *)
      Logging.Log.debug "MeBiSim:TODO END";
      Mebi_wrapper.get_proof ()
    )
  }
(*  *)
|![ proof ] 
  [ "MeBiSim" "Intros" ] ->
  { fun ~pstate -> 
    Mebi_wrapper.run ~new_proof:false ~proof:(Some pstate) (
      if Logging.is_debug_enabled () then Logging.Log.override "\n";
      Logging.Log.debug "MeBiSim:Intros BEGIN";
      let open Mebi_wrapper.Syntax in 
      let* _ = Mebi_wrapper.update_proof_by_tactics_mm 
        [ Mebi_tactics.intro_of_string "m1"
        ; Mebi_tactics.intro_of_string "act_1"
        ; Mebi_tactics.intro_of_string "H"
        ] in 
      Logging.Log.debug "MeBiSim:Intros END";
      Mebi_wrapper.get_proof ()
    )
   }
|![ proof ] 
  [ "MeBiSim" "Cofix" ] ->
  { fun ~pstate -> 
    Mebi_wrapper.run ~new_proof:false ~proof:(Some pstate) (
      if Logging.is_debug_enabled () then Logging.Log.override "\n";
      Logging.Log.debug "MeBiSim:Cofix BEGIN";
      let open Mebi_wrapper.Syntax in 
      let* _ = Mebi_wrapper.update_proof_by_tactics_mm 
        [ Mebi_tactics.cofix ()
        ; Mebi_tactics.apply_mm Mebi_theories.c_In_sim 
        ; Mebi_tactics.apply_mm Mebi_theories.c_Pack_sim 
        ] in 
      Logging.Log.debug "MeBiSim:Cofix END";
      Mebi_wrapper.get_proof ()
    )
   }
|![ proof ] 
  [ "MeBiSim" "Begin" constr(x) constr(y) ] -> 
  { fun ~pstate -> 
    Mebi_wrapper.run ~new_proof:true ~proof:(Some pstate) (
      if Logging.is_debug_enabled () then Logging.Log.override "\n";
      Logging.Log.debug "MeBiSim:Begin BEGIN";
      let open Mebi_wrapper.Syntax in 
      let* t = Mebi_tactics.unfold_constrexpr_list [x; y] in 
      let* _ = Mebi_wrapper.update_proof_by_tactic t in 
      Logging.Log.debug "MeBiSim:Begin END";
      Mebi_wrapper.get_proof ()
    )
  }
(* |![ proof ] 
  [ "MeBiSim" "Begin" 
    constr(x) (* "With" reference(a) "And" *)
    constr(y) (* "With" reference(b) "Using" reference_list(rs) *) ] -> 
  { fun ~pstate -> 
    Mebi_wrapper.run ~proof:(Some pstate) (
      if Logging.is_debug_enabled () then Logging.Log.override "\n";
      Logging.Log.debug "MeBiSim:Begin BEGIN";
      let open Mebi_wrapper.Syntax in 
      let* _ = Mebi_wrapper.update_proof_by_tactics_mm [
        Mebi_tactics.unfold_constrexpr_list [x; y]
      ; Mebi_tactics.cofix ()
      ; Mebi_tactics.apply_mm Mebi_theories.In_sim ()
      ; Mebi_tactics.apply_mm Mebi_theories.Pack_sim ()
      (* ; Mebi_tactics.intros_all () *)
      ; Mebi_tactics.intro "m1"
      ; Mebi_tactics.intro "a0_1"
      ; Mebi_tactics.intro "Hm0_1"
      ] in 
      Logging.Log.debug "MeBiSim:Begin END";
      Mebi_wrapper.get_proof ()
    )
  } *)
END

VERNAC COMMAND EXTEND MeBi_BeginProof CLASSIFIED AS QUERY
|  ![ proof_query ] 
    [ "MeBi_Bisimilarity" constr(x) "With" reference(a) 
                    "And" constr(y) "With" reference(b) 
                    "Using" reference_list(rs) ] -> 
    { fun ~pstate -> Mebi_wrapper.run ~proof:(Some pstate) (
      let open Mebi_wrapper.Syntax in 
      let* _ = Mebi_wrapper.show_names () in 
      Command.run (Command.CheckBisimilarity ((x, a), (y, b))) rs
      (* let* t = Command.tactic (Command.Bisimilarity (((x, a), (y, b)), rs)) in 
      let (p, _b) = Declare.Proof.by t pstate in
      Mebi_wrapper.return p  *)
      )
    }
END

(* VERNAC COMMAND EXTEND MeBi_Bisimilarity CLASSIFIED AS QUERY
| ![ proof ] 
   [ "MeBi_Bisimilarity" constr(x) "With" reference(a) 
                   "And" constr(y) "With" reference(b) ] -> 
   { fun ~pstate -> Mebi_wrapper.run ~keep_proof:false (
      let open Mebi_wrapper.Syntax in 
      let* _ = Mebi_wrapper.show_names () in 
      let* t = Command.tactic (Command.Bisimilarity (((x, a), (y, b)), [])) in 
      let (p, _b) = Declare.Proof.by t pstate in
      Mebi_wrapper.return p )
    }

| ![ proof ] 
   [ "MeBi_Bisimilarity" constr(x) "With" reference(a) 
                   "And" constr(y) "With" reference(b) 
                   "Using" reference_list(rs) ] -> 
    { fun ~pstate -> Mebi_wrapper.run ~keep_proof:false (
      let open Mebi_wrapper.Syntax in 
      let* _ = Mebi_wrapper.show_names () in 
      let* t = Command.tactic (Command.Bisimilarity (((x, a), (y, b)), rs)) in 
      let (p, _b) = Declare.Proof.by t pstate in
      Mebi_wrapper.return p
    )}

END *)



(* NOTE: ![proof] is modify state: https://rocq-prover.org/doc/V8.20.0/api/coq-core/Vernactypes/index.html#val-vtmodifyproof  *)
(* VERNAC COMMAND EXTEND MeBi_cofix CLASSIFIED AS QUERY
| ![ proof ]["MeBi_cofix"] -> 
   { fun ~pstate -> 
      let p = Mebi_wrapper.run ~keep_proof:true (
        let open Mebi_wrapper.Syntax in
        let* _ = Mebi_wrapper.show_names () in 
        let* n = Mebi_wrapper.new_name_of_string "TestCofix" in
        let* _ = Mebi_wrapper.show_names () in 
        let (p, _b) = Declare.Proof.by (Tactics.cofix (n)) pstate in 
        Mebi_wrapper.return p ) in 
      Logging.Log.override "vernac, check names:";
      let _ = Mebi_wrapper.run ~keep_proof:true (
        let open Mebi_wrapper.Syntax in
        let* _ = Mebi_wrapper.show_names () in 
        Mebi_wrapper.return ()) in
      p
   }
END *)

(* VERNAC COMMAND EXTEND MeBi_Bisimilarity CLASSIFIED AS QUERY
| ![ proof ] 
   [ "MeBi_Bisimilarity" constr(x) "With" reference(a) 
                   "And" constr(y) "With" reference(b) ] -> 
   { fun ~pstate -> Mebi_wrapper.run ~keep_proof:false (
      let open Mebi_wrapper.Syntax in 
      let* _ = Mebi_wrapper.show_names () in 
      let* t = Command.tactic (Command.Bisimilarity (((x, a), (y, b)), [])) in 
      let (p, _b) = Declare.Proof.by t pstate in
      Mebi_wrapper.return p )
    }

| ![ proof ] 
   [ "MeBi_Bisimilarity" constr(x) "With" reference(a) 
                   "And" constr(y) "With" reference(b) 
                   "Using" reference_list(rs) ] -> 
    { fun ~pstate -> Mebi_wrapper.run ~keep_proof:false (
      let open Mebi_wrapper.Syntax in 
      let* _ = Mebi_wrapper.show_names () in 
      let* t = Command.tactic (Command.Bisimilarity (((x, a), (y, b)), rs)) in 
      let (p, _b) = Declare.Proof.by t pstate in
      Mebi_wrapper.return p
    )}

END *)

(*** Exploring proof state ***)

(*
 * This command demonstrates exploring the proof state from within
 * a command.
 *
 * Note that Pfedit.get_current_context gets us the environment
 * and state within a proof, as opposed to the global environment
 * and state. This is important within tactics.
 *)
(* VERNAC COMMAND EXTEND MeBi_ExploreProof CLASSIFIED AS QUERY
| ![ proof_query ] [ "MeBi_ExploreProof" ] ->
  { fun ~pstate ->
    let sigma, env = Declare.Proof.get_current_context pstate in
    let pprf = Proof.partial_proof (Declare.Proof.get pstate) in
    Feedback.msg_notice
      (Pp.prlist_with_sep Pp.fnl (Printer.pr_econstr_env env sigma) pprf)
  }
END *)

TACTIC EXTEND MeBi_unfold
| ["MeBi_unfold" constr(x)] -> {Mebi_wrapper.run (Mebi_tactics.unfold_econstr x)}
END

(* TACTIC EXTEND MeBi_intros
| ["MeBi_intros"] -> {Mebi_tactics.intros ~all:true () []}
| ["MeBi_intros" string(s)] -> {Mebi_tactics.intros ~all:true () [(Mebi_tactics.Str s)]}
| ["MeBi_intros" string_list(s)] -> {Mebi_tactics.intros ~all:true () (List.map (fun (a:string) -> Mebi_tactics.Str a) s)}
| ["MeBi_intros" ident(i)] -> {Mebi_tactics.intros ~all:true () [(Mebi_tactics.Id i)]}
END *)

(* TACTIC EXTEND MeBi_intros_only
| ["MeBi_intros_only"] -> {Mebi_tactics.intros () []}
| ["MeBi_intros_only" string(s)] -> {Mebi_tactics.intros () [(Mebi_tactics.Str s)]}
| ["MeBi_intros_only" string_list(s)] -> {Mebi_tactics.intros () (List.map (fun (a:string) -> Mebi_tactics.Str a) s)}
| ["MeBi_intros_only" ident(i)] -> {Mebi_tactics.intros () [(Mebi_tactics.Id i)]}
END *)

(* TACTIC EXTEND MeBi_intro
| ["MeBi_intro"] -> {Mebi_tactics.intro () (Mebi_tactics.Unk ())}
| ["MeBi_intro" string(s)] -> {Mebi_tactics.intro () (Mebi_tactics.Str s)}
| ["MeBi_intro" ident(i)] -> {Mebi_tactics.intro () (Mebi_tactics.Id i)}
END *)

(* TACTIC EXTEND MeBiTactic
| ["MeBi" "ProofTest0"] -> {Mebi_tactics.intro () (Mebi_tactics.Unk ())}
| ["MeBi" "ProofTest0" string(s)] -> {Mebi_tactics.intro () (Mebi_tactics.Str s)}
| ["MeBi" "ProofTest0" ident(i)] -> {Mebi_tactics.intro () (Mebi_tactics.Id i)}
| ["MeBi" "ProofTest1"] -> {Proofview.tclUNIT ()}
| ["MeBi" "ProofTest2"] -> {Mebi_wrapper.run (Command.tactic (Command.ProofTest ()) )}
(* | [ "pack" "hypothesis" ident(i) ] ->{ Tuto_tactic.pack_tactic i } *)
END *)

VERNAC COMMAND EXTEND MeBiRun CLASSIFIED AS QUERY

(* set plugin params *)
| ["MeBi" "Set" "Bound" int(b)       ] -> {Params.set_bounds (b, None)}
| ["MeBi" "Set" "Bound" int(b) int(a)] -> {Params.set_bounds (b, Some a)}

| ["MeBi" "Set" "FailIfIncomplete" "True" ] -> {Params.set_fail_if_incomplete true}
| ["MeBi" "Set" "FailIfIncomplete" "False"] -> {Params.set_fail_if_incomplete false}

| ["MeBi" "Set" "FailIfNotBisim" "True" ] -> {Params.set_fail_if_not_bisim true}
| ["MeBi" "Set" "FailIfNotBisim" "False"] -> {Params.set_fail_if_not_bisim false}

| ["MeBi" "Set" "DumpToFile"  "True" ] -> {Params.set_dump_to_file true}
| ["MeBi" "Set" "DumpToFile"  "False"] -> {Params.set_dump_to_file false}

| ["MeBi" "Set" "ShowAny"   "True" ] -> {Params.set_show_any true}
| ["MeBi" "Set" "ShowAny"   "False"] -> {Params.set_show_any false}

| ["MeBi" "Set" "ShowNotices"   "True" ] -> {Params.set_show_notice true}
| ["MeBi" "Set" "ShowNotices"   "False"] -> {Params.set_show_notice false}

| ["MeBi" "Set" "ShowDebug"   "True" ] -> {Params.set_show_debug true}
| ["MeBi" "Set" "ShowDebug"   "False"] -> {Params.set_show_debug false}

| ["MeBi" "Set" "ShowDetails" "True" ] -> {Params.set_show_details true}
| ["MeBi" "Set" "ShowDetails" "False"] -> {Params.set_show_details false}

| ["MeBi" "Set" "ShowResults"   "True" ] -> {Params.set_show_result true}
| ["MeBi" "Set" "ShowResults"   "False"] -> {Params.set_show_result false}

| ["MeBi" "Set" "ShowWarnings"   "True" ] -> {Params.set_show_warning true}
| ["MeBi" "Set" "ShowWarnings"   "False"] -> {Params.set_show_warning false}

| ["MeBi" "Set" "WeakMode"    "True" ] -> {Params.set_weak_mode true}
| ["MeBi" "Set" "WeakMode"    "False"] -> {Params.set_weak_mode false}

(* set the weak transitions -- bisim will use for both terms unless specified *)
| ["MeBi" "Set" "Weak" "Option" constr(x)   ] -> {Params.set_weak_types_args (Params.WeakArgs.OptionConstr x, None)}
| ["MeBi" "Set" "Weak" constr(x)    "Of" reference(y)] -> {Params.set_weak_types_args (Params.WeakArgs.CustomConstr (x, y), None)}

(* specify weak transition for first lts *)
| ["MeBi" "Set" "Weak1" "Option" constr(x)   ] -> {Params.set_fst_weak_type_arg (Params.WeakArgs.OptionConstr x); Logging.Log.notice "Set Weak1 param."}
| ["MeBi" "Set" "Weak1" constr(x)    "Of" reference(y)] -> {Params.set_fst_weak_type_arg (Params.WeakArgs.CustomConstr (x, y)); Logging.Log.notice "Set Weak1 param."}

(* specify weak transition for second lts *)
| ["MeBi" "Set" "Weak2" "Option" constr(x)   ] -> {Params.set_snd_weak_type_arg (Params.WeakArgs.OptionConstr x); Logging.Log.notice "Set Weak2 param."}
| ["MeBi" "Set" "Weak2" constr(x)    "Of" reference(y)] -> {Params.set_snd_weak_type_arg (Params.WeakArgs.CustomConstr (x, y)); Logging.Log.notice "Set Weak2 param."}

(* reset plugin params *)
| ["MeBi" "Reset" "Bound"      ] -> {Params.reset_bounds ()}
| ["MeBi" "Reset" "FailIfIncomplete" ] -> {Params.reset_fail_if_incomplete ()}
| ["MeBi" "Reset" "FailIfNotBisim" ] -> {Params.reset_fail_if_not_bisim ()}
| ["MeBi" "Reset" "DumpToFile" ] -> {Params.reset_dump_to_file ()}
| ["MeBi" "Reset" "ShowAny"  ] -> {Params.reset_show_any ()}
| ["MeBi" "Reset" "ShowNotice"  ] -> {Params.reset_show_notice ()}
| ["MeBi" "Reset" "ShowDebug"  ] -> {Params.reset_show_debug ()}
| ["MeBi" "Reset" "ShowDetails"] -> {Params.reset_show_details ()}
| ["MeBi" "Reset" "ShowResults"] -> {Params.reset_show_result ()}
| ["MeBi" "Reset" "ShowWarning"] -> {Params.reset_show_warning ()}
| ["MeBi" "Reset" "WeakMode"   ] -> {Params.reset_weak_mode ()}
| ["MeBi" "Reset" "Weak"       ] -> {Params.reset_weak_types ()}
| ["MeBi" "Reset" "All"        ] -> {Mebi_wrapper.run (Params.reset_all ())}

(* check plugin params *)
| ["MeBi" "See" "Bound"      ] -> {Params.printout_bounds ()}
| ["MeBi" "See" "FailIfIncomplete" ] -> {Params.printout_fail_if_incomplete ()}
| ["MeBi" "See" "FailIfNotBisim" ] -> {Params.printout_fail_if_not_bisim ()}
| ["MeBi" "See" "DumpToFile" ] -> {Params.printout_dump_to_file ()}
| ["MeBi" "See" "ShowAny"  ] -> {Params.printout_show_any ()}
| ["MeBi" "See" "ShowNotice"  ] -> {Params.printout_show_notice ()}
| ["MeBi" "See" "ShowDebug"  ] -> {Params.printout_show_debug ()}
| ["MeBi" "See" "ShowDetails"] -> {Params.printout_show_details ()}
| ["MeBi" "See" "ShowResults"] -> {Params.printout_show_result ()}
| ["MeBi" "See" "ShowWarning"] -> {Params.printout_show_warning ()}
| ["MeBi" "See" "WeakMode"   ] -> {Params.printout_weak_mode ()}
| ["MeBi" "See" "Weak"       ] -> {Mebi_wrapper.run (Params.printout_weak_types ())}
| ["MeBi" "See" "Weak1"      ] -> {Mebi_wrapper.run (Params.printout_fst_weak_type ())}
| ["MeBi" "See" "Weak2"      ] -> {Mebi_wrapper.run (Params.printout_snd_weak_type ())}
| ["MeBi" "See" "All"        ] -> {Mebi_wrapper.run (Params.printout_all ())}


| ["MeBi" "LTS" constr(x) "Using" reference(r)] -> {Mebi_wrapper.run (Command.run (Command.MakeModel (Command.LTS, (x, r))) [])}
| ["MeBi" "LTS" constr(x) "Using" reference(r) 
                            reference_list(rs)] -> {Mebi_wrapper.run (Command.run (Command.MakeModel (Command.LTS, (x, r))) rs)}

| ["MeBi" "FSM" constr(x) "Using" reference(r)] -> {Mebi_wrapper.run (Command.run (Command.MakeModel (Command.FSM, (x, r))) [])}
| ["MeBi" "FSM" constr(x) "Using" reference(r) 
                            reference_list(rs)] -> {Mebi_wrapper.run (Command.run (Command.MakeModel (Command.FSM, (x, r))) rs)}

| ["MeBi" "Saturate" constr(x) "Using" reference(r)] -> {Mebi_wrapper.run (Command.run (Command.SaturateModel (x, r)) [])}
| ["MeBi" "Saturate" constr(x) "Using" reference(r) 
                                 reference_list(rs)] -> {Mebi_wrapper.run (Command.run (Command.SaturateModel (x, r)) rs)}

| ["MeBi" "Minimize" constr(x) "Using" reference(r)] -> {Mebi_wrapper.run (Command.run (Command.MinimizeModel (x, r)) [])}
| ["MeBi" "Minimize" constr(x) "Using" reference(r) 
                                 reference_list(rs)] -> {Mebi_wrapper.run (Command.run (Command.MinimizeModel (x, r)) rs)}

| ["MeBi" "Bisim" constr(x) "With" reference(a) 
            "And" constr(y) "With" reference(b)] -> {Mebi_wrapper.run (Command.run (Command.CheckBisimilarity ((x, a), (y, b))) [])}
| ["MeBi" "Bisim" constr(x) "With" reference(a) 
            "And" constr(y) "With" reference(b) 
                     "Using" reference_list(rs)] -> {Mebi_wrapper.run (Command.run (Command.CheckBisimilarity ((x, a), (y, b))) rs)}

| ["MeBi" "Help"] -> {Mebi_wrapper.run (Command.run (Command.Help (Mebi_help.Basic ())) [])}

| ["MeBi" "Help" "Set"              ] -> {Mebi_wrapper.run (Command.run (Command.Help (Mebi_help.Set (Mebi_help.General ()))) [])}
| ["MeBi" "Help" "Set" "Bound"      ] -> {Mebi_wrapper.run (Command.run (Command.Help (Mebi_help.Set (Mebi_help.Bound ()))) [])}
| ["MeBi" "Help" "Set" "FailIfIncomplete" ] -> {Mebi_wrapper.run (Command.run (Command.Help (Mebi_help.Set (Mebi_help.FailIfIncomplete ()))) [])}
| ["MeBi" "Help" "Set" "FailIfNotBisim" ] -> {Mebi_wrapper.run (Command.run (Command.Help (Mebi_help.Set (Mebi_help.FailIfNotBisim ()))) [])}
| ["MeBi" "Help" "Set" "DumpToFile" ] -> {Mebi_wrapper.run (Command.run (Command.Help (Mebi_help.Set (Mebi_help.DumpToFile ()))) [])}
| ["MeBi" "Help" "Set" "ShowAny"  ] -> {Mebi_wrapper.run (Command.run (Command.Help (Mebi_help.Set (Mebi_help.ShowAny ()))) [])}
| ["MeBi" "Help" "Set" "ShowNotice"  ] -> {Mebi_wrapper.run (Command.run (Command.Help (Mebi_help.Set (Mebi_help.ShowNotices ()))) [])}
| ["MeBi" "Help" "Set" "ShowDebug"  ] -> {Mebi_wrapper.run (Command.run (Command.Help (Mebi_help.Set (Mebi_help.ShowDebug ()))) [])}
| ["MeBi" "Help" "Set" "ShowDetails"] -> {Mebi_wrapper.run (Command.run (Command.Help (Mebi_help.Set (Mebi_help.ShowDetails ()))) [])}
| ["MeBi" "Help" "Set" "ShowResults"  ] -> {Mebi_wrapper.run (Command.run (Command.Help (Mebi_help.Set (Mebi_help.ShowResults ()))) [])}
| ["MeBi" "Help" "Set" "ShowWarning"  ] -> {Mebi_wrapper.run (Command.run (Command.Help (Mebi_help.Set (Mebi_help.ShowWarnings ()))) [])}
| ["MeBi" "Help" "Set" "WeakMode"   ] -> {Mebi_wrapper.run (Command.run (Command.Help (Mebi_help.Set (Mebi_help.WeakMode ()))) [])}
| ["MeBi" "Help" "Set" "Weak"       ] -> {Mebi_wrapper.run (Command.run (Command.Help (Mebi_help.Set (Mebi_help.Weak ()))) [])}

| ["MeBi" "Help" "Reset"] -> {Mebi_wrapper.run (Command.run (Command.Help (Mebi_help.Reset ())) [])}
| ["MeBi" "Help" "Check"] -> {Mebi_wrapper.run (Command.run (Command.Help (Mebi_help.See ())) [])}

| ["MeBi" "Help" "LTS"] -> {Mebi_wrapper.run (Command.run (Command.Help (Mebi_help.LTS ())) [])}
| ["MeBi" "Help" "FSM"] -> {Mebi_wrapper.run (Command.run (Command.Help (Mebi_help.FSM ())) [])}

| ["MeBi" "Help" "Saturate"] -> {Mebi_wrapper.run (Command.run (Command.Help (Mebi_help.Saturate ())) [])}
| ["MeBi" "Help" "Minimize"] -> {Mebi_wrapper.run (Command.run (Command.Help (Mebi_help.Minimize ())) [])}

| ["MeBi" "Help" "Bisim"] -> {Mebi_wrapper.run (Command.run (Command.Help (Mebi_help.Bisim ())) [])}

| ["MeBi" "Help" "Info"] -> {Mebi_wrapper.run (Command.run (Command.Help (Mebi_help.Info ())) [])}

| ["MeBi" ] -> {Mebi_wrapper.run (Command.run (Command.Help (Mebi_help.Unrecognized ())) [])}

| ["MeBi" "Info"] -> {Mebi_wrapper.run (Command.run (Command.Info ()) [])}

(* for outputting messages -- useful for sifting through compiler output *)
| ["MeBi" "Message" string(x)] -> {Logging.Log.override x}
| ["MeBi" "Debug"   string(x)] -> {Logging.Log.debug x}
| ["MeBi" "Divider"          ] -> {Logging.Log.override "\n- - - - - - - - - - - - - - - -\n"}
| ["MeBi" string(x) "Divider"] -> {Logging.Log.override (Printf.sprintf "%s\n- - - - - - - - - - - - - - - -\n" x)}
| ["MeBi" "Divider" string(x)] -> {Logging.Log.override (Printf.sprintf "\n- - - - - - - - - - - - - - - -\n%s\n" x)}
| ["MeBi" string(x) "Divider" string(y)] -> 
  {Logging.Log.override (Printf.sprintf "%s\n- - - - - - - - - - - - - - - -\n%s\n" x y)}
END
