DECLARE PLUGIN "coq-mebi.mebi"

{
(* If we forget this line and include our own tactic definition using
  TACTIC EXTEND, as below, then we get the strange error message
  no implementation available for Tacentries, only when compiling
  theories/Loader.v *)
(* open Ltac_plugin *)

open Stdarg
(* open Pp *)
}

(* https://github.com/rocq-prover/rocq/blob/master/doc/plugin_tutorial/tuto0/src/g_tuto0.mlg *)
(* https://github.com/rocq-prover/rocq/blob/master/doc/plugin_tutorial/tuto1/src/g_tuto1.mlg *)
(* https://github.com/rocq-prover/rocq/blob/master/doc/plugin_tutorial/tuto2/src/g_tuto2.mlg *)

(* https://github.com/rocq-prover/rocq/blob/master/dev/doc/parsing.md *)

(*

  # Syntax of MeBi commands

  {C} ::= MeBi                            : syntax of commands {C}
          [ Check | Show |                : feedback/output mode
            Dump  | Dump <name> ]   
          [ {L} | {F} | {A} ]             : kind of command to run
                                              {L} => build LTS
                                              {F} => build FSM
                                              {A} => run algorithm
          Using <lts_list>                : list of lts/constructors (outermost-first)

  {L} ::= LTS                             : syntax of LTS model (term + lts)
          [ Is Bounded <num> |            : (optional) raise error if bound exceeded
            Bounded <num>    |            : (optional) upper-bound
          Of <term>                       : initial term

  {F} ::= FSM From {L}                    : build ocaml FSM from extracted LTS

  {A} ::= [ {B} | {M} | {G} ]             : kinds of algorithms to run
                                              {G} => Merge
                                              {B} => Bisimilarity
                                              {M} => Minimization

  {G} ::= Merge {L} {L}                   : run merge algorithm

  {B} ::= Bisim {L} {L}                   : run bisimilarity algorithm

  {M} ::= Minim {L}                       : run minimization algorithm

  ---------------------------------------

  # Examples

  - [MeBi Show LTS Of p Using a b c.]
    Builds an lts of term [p] using coq-lts [a], [b] and [c]
    (using a default bound), and displays in feedback window.

  - [MeBi Check n LTS Of p Using a.]
    Does the same as the above, but nothing is printed, displayed or outputted.

  - [MeBi Show LTS Bounded 5 Of p Using a b c.]
    Builds an lts of term [p] using coq-lts [a], [b] and [c]
    until 5 states are reached, and displays in feedback window.

  - [MeBi Check n LTS Is Bounded 5 Of p Using a.]
    Does the same as the above, but nothing is printed, displayed or outputted,
    and if the LTS is not complete within the bounds, then raises failure.

  - [MeBi Dump LTS Of p Using a b c.]
    Builds an lts of term [p] using coq-lts [a], [b] and [c]
    and then dumps to (json) file.

  - [MeBi Dump n LTS Of p Using a b c.]
    Builds an lts of term [p] using coq-lts [a], [b] and [c]
    and then dumps to (json) file with name [n].

  *)

VERNAC COMMAND EXTEND MeBiLTS CLASSIFIED AS QUERY

(******************************)
(** Build LTS from coq term ***)
(******************************)
| [ "MeBi" "Check" "LTS" "Of" constr(t) "Using" reference_list(r) ] ->
    {Mebi_wrapper.run (Command.vernac (Vernac.Check ()) (Vernac.LTS (false, Command.default_bound, t), r))}

| [ "MeBi" "Check" "LTS" "Bounded" int(i) "Of" constr(t) "Using" reference_list(r) ] ->
    {Mebi_wrapper.run (Command.vernac (Vernac.Check ()) (Vernac.LTS (false, i, t), r))}

| [ "MeBi" "Check" "LTS" "Is" "Bounded" int(i) "Of" constr(t) "Using" reference_list(r) ] ->
    {Mebi_wrapper.run (Command.vernac (Vernac.Check ()) (Vernac.LTS (true, i, t), r))}

| [ "MeBi" "Show" "LTS" "Of" constr(t) "Using" reference_list(r) ] ->
    {Mebi_wrapper.run (Command.vernac (Vernac.Show ()) (Vernac.LTS (false, Command.default_bound, t), r))}

| [ "MeBi" "Show" "LTS" "Bounded" int(i) "Of" constr(t) "Using" reference_list(r) ] ->
    {Mebi_wrapper.run (Command.vernac (Vernac.Show ()) (Vernac.LTS (false, i, t), r))}

| [ "MeBi" "Show" "LTS" "Is" "Bounded" int(i) "Of" constr(t) "Using" reference_list(r) ] ->
    {Mebi_wrapper.run (Command.vernac (Vernac.Show ()) (Vernac.LTS (true, i, t), r))}

| [ "MeBi" "Dump" "LTS" "Of" constr(t) "Using" reference_list(r) ] ->
    {Mebi_wrapper.run (Command.vernac (Vernac.Dump None) (Vernac.LTS (false, Command.default_bound, t), r))}

| [ "MeBi" "Dump" "LTS" "Bounded" int(i) "Of" constr(t) "Using" reference_list(r) ] ->
    {Mebi_wrapper.run (Command.vernac (Vernac.Dump None) (Vernac.LTS (false, i, t), r))}

| [ "MeBi" "Dump" "LTS" "Is" "Bounded" int(i) "Of" constr(t) "Using" reference_list(r) ] ->
    {Mebi_wrapper.run (Command.vernac (Vernac.Dump None) (Vernac.LTS (true, i, t), r))}

| [ "MeBi" "Dump" string(n) "LTS" "Of" constr(t) "Using" reference_list(r) ] ->
    {Mebi_wrapper.run (Command.vernac (Vernac.Dump (Some n)) (Vernac.LTS (false, Command.default_bound, t), r))}

| [ "MeBi" "Dump" string(n) "LTS" "Bounded" int(i) "Of" constr(t) "Using" reference_list(r) ] ->
    {Mebi_wrapper.run (Command.vernac (Vernac.Dump (Some n)) (Vernac.LTS (false, i, t), r))}

| [ "MeBi" "Dump" string(n) "LTS" "Is" "Bounded" int(i) "Of" constr(t) "Using" reference_list(r) ] ->
    {Mebi_wrapper.run (Command.vernac (Vernac.Dump (Some n)) (Vernac.LTS (true, i, t), r))}

(******************************)
(** Build FSM from coq term ***) (* same as the above but with [Vernac.FSM] *)
(******************************)
| [ "MeBi" "Check" "FSM" "Of" constr(t) "Using" reference_list(r) ] ->
    {Mebi_wrapper.run (Command.vernac (Vernac.Check ()) (Vernac.FSM (false, Command.default_bound, t), r))}

| [ "MeBi" "Check" "FSM" "Bounded" int(i) "Of" constr(t) "Using" reference_list(r) ] ->
    {Mebi_wrapper.run (Command.vernac (Vernac.Check ()) (Vernac.FSM (false, i, t), r))}

| [ "MeBi" "Check" "FSM" "Is" "Bounded" int(i) "Of" constr(t) "Using" reference_list(r) ] ->
    {Mebi_wrapper.run (Command.vernac (Vernac.Check ()) (Vernac.FSM (true, i, t), r))}

| [ "MeBi" "Show" "FSM" "Of" constr(t) "Using" reference_list(r) ] ->
    {Mebi_wrapper.run (Command.vernac (Vernac.Show ()) (Vernac.FSM (false, Command.default_bound, t), r))}

| [ "MeBi" "Show" "FSM" "Bounded" int(i) "Of" constr(t) "Using" reference_list(r) ] ->
    {Mebi_wrapper.run (Command.vernac (Vernac.Show ()) (Vernac.FSM (false, i, t), r))}

| [ "MeBi" "Show" "FSM" "Is" "Bounded" int(i) "Of" constr(t) "Using" reference_list(r) ] ->
    {Mebi_wrapper.run (Command.vernac (Vernac.Show ()) (Vernac.FSM (true, i, t), r))}

| [ "MeBi" "Dump" "FSM" "Of" constr(t) "Using" reference_list(r) ] ->
    {Mebi_wrapper.run (Command.vernac (Vernac.Dump None) (Vernac.FSM (false, Command.default_bound, t), r))}

| [ "MeBi" "Dump" "FSM" "Bounded" int(i) "Of" constr(t) "Using" reference_list(r) ] ->
    {Mebi_wrapper.run (Command.vernac (Vernac.Dump None) (Vernac.FSM (false, i, t), r))}

| [ "MeBi" "Dump" "FSM" "Is" "Bounded" int(i) "Of" constr(t) "Using" reference_list(r) ] ->
    {Mebi_wrapper.run (Command.vernac (Vernac.Dump None) (Vernac.FSM (true, i, t), r))}

| [ "MeBi" "Dump" string(n) "FSM" "Of" constr(t) "Using" reference_list(r) ] ->
    {Mebi_wrapper.run (Command.vernac (Vernac.Dump (Some n)) (Vernac.FSM (false, Command.default_bound, t), r))}

| [ "MeBi" "Dump" string(n) "FSM" "Bounded" int(i) "Of" constr(t) "Using" reference_list(r) ] ->
    {Mebi_wrapper.run (Command.vernac (Vernac.Dump (Some n)) (Vernac.FSM (false, i, t), r))}

| [ "MeBi" "Dump" string(n) "FSM" "Is" "Bounded" int(i) "Of" constr(t) "Using" reference_list(r) ] ->
    {Mebi_wrapper.run (Command.vernac (Vernac.Dump (Some n)) (Vernac.FSM (true, i, t), r))}

END


(*


(*
 * TODO: so far, classified as query. What it should do: read proposition, check
 * it has the corret type. Print proposition.
 *)
VERNAC COMMAND EXTEND MeBiLTS CLASSIFIED AS QUERY
  (***************************)
  (**** Coq -> LTS  **********)
  (***************************)
  (* build lts for [t] using [r] (default bounds) *)
  | [ "MeBi" "Show" "LTS"
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.LTS.show
        ~params:(Utils.Params.Default.log ~mode:(Coq()) ())
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  | [ "MeBi" "Dump" string(name) "LTS"
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.LTS.dump
        ~params:(Utils.Params.Default.log ~mode:(Coq()) ())
        ~name
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  | [ "MeBi" "Debug" "LTS"
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.LTS.show
        ~params:(
          let params = (Utils.Params.Default.log ~mode:(Coq()) ()) in
          params.options <-
          { output_enabled=true;
            show_normal_output=true;
            show_detailed_output=true;
            show_debug_output=true;
            show_warning_output=true };
          params
        )
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  (* build lts for [t] using [r], within bound [i] *)
  | [ "MeBi" "Show" "LTS" "Bounded" int(i)
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.LTS.show
        ~params:(Utils.Params.Default.log ~mode:(Coq()) ())
        ~bound:i
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  | [ "MeBi" "Dump" string(name) "LTS" "Bounded" int(i)
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.LTS.dump
        ~params:(Utils.Params.Default.log ~mode:(Coq()) ())
        ~bound:i
        ~name
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  | [ "MeBi" "Debug" "LTS" "Bounded" int(i)
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.LTS.show
        ~params:(
          let params = (Utils.Params.Default.log ~mode:(Coq()) ()) in
          params.options <-
          { output_enabled=true;
            show_normal_output=true;
            show_detailed_output=true;
            show_debug_output=true;
            show_warning_output=true };
          params
        )
        ~bound:i
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  (******************************)
  (**** Coq -> LTS (with equiv) *)
  (******************************)
  (* build lts for [t] using [r] (default bounds) *)
  | [ "MeBi" "Show" "LTS" reference(e)
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.LTS.show
        ~params:(Utils.Params.Default.log ~mode:(Coq()) ())
        t
        (Mebi_utils.ref_list_to_glob_list r)
        ~equiv:(Nametab.global e)
        ) }
  | [ "MeBi" "Dump" string(name) "LTS" reference(e)
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.LTS.dump
        ~params:(Utils.Params.Default.log ~mode:(Coq()) ())
        ~name
        ~equiv:(Nametab.global e)
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  | [ "MeBi" "Debug" "LTS" reference(e)
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.LTS.show
        ~params:(
          let params = (Utils.Params.Default.log ~mode:(Coq()) ()) in
          params.options <-
          { output_enabled=true;
            show_normal_output=true;
            show_detailed_output=true;
            show_debug_output=true;
            show_warning_output=true };
          params
        )
        ~equiv:(Nametab.global e)
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  (* build lts for [t] using [r], within bound [i] *)
  | [ "MeBi" "Show" "LTS" reference(e) "Bounded" int(i)
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.LTS.show
        ~params:(Utils.Params.Default.log ~mode:(Coq()) ())
        ~bound:i
        ~equiv:(Nametab.global e)
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  | [ "MeBi" "Dump" string(name) "LTS" reference(e) "Bounded" int(i)
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.LTS.dump
        ~params:(Utils.Params.Default.log ~mode:(Coq()) ())
        ~bound:i
        ~name
        ~equiv:(Nametab.global e)
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  | [ "MeBi" "Debug" "LTS" reference(e) "Bounded" int(i)
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.LTS.show
        ~params:(
          let params = (Utils.Params.Default.log ~mode:(Coq()) ()) in
          params.options <-
          { output_enabled=true;
            show_normal_output=true;
            show_detailed_output=true;
            show_debug_output=true;
            show_warning_output=true };
          params
        )
        ~bound:i
        ~equiv:(Nametab.global e)
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  (***************************)
  (**** Coq -> LTS -> FSM ****)
  (***************************)
  (* build fsm from lts for [t] using [r] (default bounds) *)
  | [ "MeBi" "Show" "FSM"
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.FSM.show
        ~params:(Utils.Params.Default.log ~mode:(Coq()) ())
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  | [ "MeBi" "Dump" string(name) "FSM"
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.FSM.dump
        ~params:(Utils.Params.Default.log ~mode:(Coq()) ())
        ~name
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  | [ "MeBi" "Debug" "FSM"
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.FSM.show
        ~params:(
          let params = (Utils.Params.Default.log ~mode:(Coq()) ()) in
          params.options <-
          { output_enabled=true;
            show_normal_output=true;
            show_detailed_output=true;
            show_debug_output=true;
            show_warning_output=true };
          params
        )
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  (* build fsm from lts for [t] using [r], within bound [i] *)
  | [ "MeBi" "Show" "FSM" "Bounded" int(i)
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.FSM.show
        ~params:(Utils.Params.Default.log ~mode:(Coq()) ())
        ~bound:i
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  | [ "MeBi" "Dump" string(name) "FSM" "Bounded" int(i)
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.FSM.dump
        ~params:(Utils.Params.Default.log ~mode:(Coq()) ())
        ~bound:i
        ~name
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  | [ "MeBi" "Debug" "FSM" "Bounded" int(i)
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.FSM.show
        ~params:(
          let params = (Utils.Params.Default.log ~mode:(Coq()) ()) in
          params.options <-
          { output_enabled=true;
            show_normal_output=true;
            show_detailed_output=true;
            show_debug_output=true;
            show_warning_output=true };
          params
        )
        ~bound:i
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  (*************************************)
  (**** Coq -> LTS (with equiv) -> FSM *)
  (*************************************)
  (* build fsm from lts for [t] using [r] (default bounds) *)
  | [ "MeBi" "Show" "FSM" reference(e)
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.FSM.show
        ~params:(Utils.Params.Default.log ~mode:(Coq()) ())
        ~equiv:(Nametab.global e)
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  | [ "MeBi" "Dump" string(name) "FSM" reference(e)
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.FSM.dump
        ~params:(Utils.Params.Default.log ~mode:(Coq()) ())
        ~name
        ~equiv:(Nametab.global e)
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  | [ "MeBi" "Debug" "FSM" reference(e)
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.FSM.show
        ~params:(
          let params = (Utils.Params.Default.log ~mode:(Coq()) ()) in
          params.options <-
          { output_enabled=true;
            show_normal_output=true;
            show_detailed_output=true;
            show_debug_output=true;
            show_warning_output=true };
          params
        )
        ~equiv:(Nametab.global e)
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  (* build fsm from lts for [t] using [r], within bound [i] *)
  | [ "MeBi" "Show" "FSM" reference(e) "Bounded" int(i)
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.FSM.show
        ~params:(Utils.Params.Default.log ~mode:(Coq()) ())
        ~bound:i
        ~equiv:(Nametab.global e)
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  | [ "MeBi" "Dump" string(name) "FSM" reference(e) "Bounded" int(i)
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.FSM.dump
        ~params:(Utils.Params.Default.log ~mode:(Coq()) ())
        ~bound:i
        ~name
        ~equiv:(Nametab.global e)
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  | [ "MeBi" "Debug" "FSM" reference(e) "Bounded" int(i)
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.FSM.show
        ~params:(
          let params = (Utils.Params.Default.log ~mode:(Coq()) ()) in
          params.options <-
          { output_enabled=true;
            show_normal_output=true;
            show_detailed_output=true;
            show_debug_output=true;
            show_warning_output=true };
          params
        )
        ~bound:i
        ~equiv:(Nametab.global e)
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  (****************************************************)
  (**** Coq A -> LTS A -> FSM A -> Minim A ************)
  (****************************************************)
  (* build fsm from lts for [t] using [r] (default bounds), and run minum *)
  | [ "MeBi" "Show" "Minim"
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.Minim.show
        ~params:(Utils.Params.Default.log ~mode:(Coq()) ())
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  | [ "MeBi" "Dump" string(name) "Minim"
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.Minim.dump
        ~params:(Utils.Params.Default.log ~mode:(Coq()) ())
        ~name
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  | [ "MeBi" "Debug" "Minim"
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.Minim.show
        ~params:(
          let params = (Utils.Params.Default.log ~mode:(Coq()) ()) in
          params.options <-
          { output_enabled=true;
            show_normal_output=true;
            show_detailed_output=true;
            show_debug_output=true;
            show_warning_output=true };
          params
        )
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  (* build fsm from lts for [t] using [r], within bound [i], and run minum *)
  | [ "MeBi" "Show" "Minim" "Bounded" int(i)
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.Minim.show
        ~params:(Utils.Params.Default.log ~mode:(Coq()) ())
        ~bound:i
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  | [ "MeBi" "Dump" string(name) "Minim" "Bounded" int(i)
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.Minim.dump
        ~params:(Utils.Params.Default.log ~mode:(Coq()) ())
        ~bound:i
        ~name
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  | [ "MeBi" "Debug" "Minim" "Bounded" int(i)
      "Of" constr(t) "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.Minim.show
        ~params:(
          let params = (Utils.Params.Default.log ~mode:(Coq()) ()) in
          params.options <-
          { output_enabled=true;
            show_normal_output=true;
            show_detailed_output=true;
            show_debug_output=true;
            show_warning_output=true };
          params
        )
        ~bound:i
        t
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  (****************************************************)
  (**** Coq A B -> LTS A B -> FSM A B -> Merge A B ****)
  (****************************************************)
  (* build two fsms from two different lts and merge them *)
  | [ "MeBi" "Show" "FSM" "Merge"
      "Of" constr(tA)
      "With" constr(tB)
      "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.Merged.show
        ~params:(Utils.Params.Default.log ~mode:(Coq()) ())
        tA
        tB
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  | [ "MeBi" "Dump" string(name) "FSM" "Merge"
      "Of" constr(tA)
      "With" constr(tB)
      "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.Merged.dump
        ~params:(Utils.Params.Default.log ~mode:(Coq()) ())
        ~name
        tA
        tB
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  | [ "MeBi" "Debug" "FSM" "Merge"
      "Of" constr(tA)
      "With" constr(tB)
      "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.Merged.show
        ~params:(
          let params = (Utils.Params.Default.log ~mode:(Coq()) ()) in
          params.options <-
          { output_enabled=true;
            show_normal_output=true;
            show_detailed_output=true;
            show_debug_output=true;
            show_warning_output=true };
          params
        )
        tA
        tB
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  (* build two fsms from two different lts and merge them, within bound [i] *)
  | [ "MeBi" "Show" "FSM" "Merge" "Bounded" int(i)
      "Of" constr(tA)
      "With" constr(tB)
      "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.Merged.show
        ~params:(Utils.Params.Default.log ~mode:(Coq()) ())
        ~bound:i
        tA
        tB
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  | [ "MeBi" "Dump" string(name) "FSM" "Merge" "Bounded" int(i)
      "Of" constr(tA)
      "With" constr(tB)
      "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.Merged.dump
        ~params:(Utils.Params.Default.log ~mode:(Coq()) ())
        ~bound:i
        ~name
        tA
        tB
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  | [ "MeBi" "Debug" "FSM" "Merge" "Bounded" int(i)
      "Of" constr(tA)
      "With" constr(tB)
      "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.Merged.show
        ~params:(
          let params = (Utils.Params.Default.log ~mode:(Coq()) ()) in
          params.options <-
          { output_enabled=true;
            show_normal_output=true;
            show_detailed_output=true;
            show_debug_output=true;
            show_warning_output=true };
          params
        )
        ~bound:i
        tA
        tB
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  (****************************************************)
  (**** Coq A B -> LTS A B -> FSM A B -> Bisim A M ****)
  (****************************************************)
  (* check if two fsms built from lts are bisimiular *)
  | [ "MeBi" "Show" "Bisim"
      "Of" constr(tA)
      "With" constr(tB)
      "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.Bisim.show
        ~params:(Utils.Params.Default.log ~mode:(Coq()) ())
        tA
        tB
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  | [ "MeBi" "Dump" string(name) "Bisim"
      "Of" constr(tA)
      "With" constr(tB)
      "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.Bisim.dump
        ~params:(Utils.Params.Default.log ~mode:(Coq()) ())
        ~name
        tA
        tB
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  | [ "MeBi" "Debug" "Bisim"
      "Of" constr(tA)
      "With" constr(tB)
      "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.Bisim.show
        ~params:(
          let params = (Utils.Params.Default.log ~mode:(Coq()) ()) in
          params.options <-
          { output_enabled=true;
            show_normal_output=true;
            show_detailed_output=true;
            show_debug_output=true;
            show_warning_output=true };
          params
        )
        tA
        tB
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  (* check if two fsms built from lts within bound [i] are bisimiular *)
  | [ "MeBi" "Show" "Bisim" "Bounded" int(i)
      "Of" constr(tA)
      "With" constr(tB)
      "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.Bisim.show
        ~params:(Utils.Params.Default.log ~mode:(Coq()) ())
        ~bound:i
        tA
        tB
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  | [ "MeBi" "Dump" string(name) "Bisim" "Bounded" int(i)
      "Of" constr(tA)
      "With" constr(tB)
      "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.Bisim.dump
        ~params:(Utils.Params.Default.log ~mode:(Coq()) ())
        ~bound:i
        ~name
        tA
        tB
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
  | [ "MeBi" "Debug" "Bisim" "Bounded" int(i)
      "Of" constr(tA)
      "With" constr(tB)
      "Using" reference_list(r) ] ->
    { Mebi_wrapper.run (
      Vernac.Vernac.Bisim.show
        ~params:(
          let params = (Utils.Params.Default.log ~mode:(Coq()) ()) in
          params.options <-
          { output_enabled=true;
            show_normal_output=true;
            show_detailed_output=true;
            show_debug_output=true;
            show_warning_output=true };
          params
        )
        ~bound:i
        tA
        tB
        (Mebi_utils.ref_list_to_glob_list r)
      ) }
END
*)